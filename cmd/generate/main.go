package main

import (
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/steemit/steemutil/protocol/api"
	"github.com/steemit/steemutil/protocol/broadcast"
)

const apiGenTemplate = `package api

// Code generated by cmd/generate/main.go. DO NOT EDIT.

{{range .Methods}}
// {{.MethodName}} calls {{.API}}.{{.Method}}.
func (a *API) {{.MethodName}}({{.ParamsSignature}}) ({{.ReturnType}}, error) {
	params := []interface{}{ {{.ParamsValues}} }
	{{if .HasResult}}
	var result {{.ResultType}}
	err := a.CallWithResult("{{.API}}", "{{.Method}}", params, &result)
	return result, err
	{{else}}
	_, err := a.Call("{{.API}}", "{{.Method}}", params)
	return err
	{{end}}
}
{{end}}
`

const broadcastGenTemplate = `package broadcast

// Code generated by cmd/generate/main.go. DO NOT EDIT.

{{range .Operations}}
// {{.MethodName}} creates and broadcasts a {{.Operation}} operation.
func (b *Broadcast) {{.MethodName}}({{.ParamsSignature}}) ([]byte, error) {
	op := &protocol.{{.OpType}}{
		{{.OpFields}}
	}
	privKeys := map[string]string{
		"{{.Role}}": privKeyWif,
	}
	return b.Send([]protocol.Operation{op}, privKeys)
}
{{end}}
`

func main() {
	// Generate API methods
	if err := generateAPIMethods(); err != nil {
		fmt.Fprintf(os.Stderr, "Error generating API methods: %v\n", err)
		os.Exit(1)
	}

	// Generate Broadcast methods
	if err := generateBroadcastMethods(); err != nil {
		fmt.Fprintf(os.Stderr, "Error generating Broadcast methods: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("Code generation completed successfully!")
}

func generateAPIMethods() error {
	methods := api.MethodsData

	// Process methods for template
	type MethodData struct {
		MethodName     string
		API            string
		Method         string
		ParamsSignature string
		ParamsValues   string
		ReturnType     string
		HasResult      bool
		ResultType     string
	}

	methodDataList := make([]MethodData, 0, len(methods))
	for _, method := range methods {
		methodName := method.MethodName
		if methodName == "" {
			methodName = toCamelCase(method.Method)
		}

		paramsSig := buildParamsSignature(method.Params)
		paramsValues := buildParamsValues(method.Params, method.IsObject)
		returnType := "error"
		hasResult := true
		resultType := "interface{}"

		md := MethodData{
			MethodName:      methodName,
			API:             method.API,
			Method:          method.Method,
			ParamsSignature: paramsSig,
			ParamsValues:    paramsValues,
			ReturnType:      returnType,
			HasResult:       hasResult,
			ResultType:      resultType,
		}
		methodDataList = append(methodDataList, md)
	}

	// Generate code
	tmpl, err := template.New("api").Parse(apiGenTemplate)
	if err != nil {
		return err
	}

	var buf strings.Builder
	if err := tmpl.Execute(&buf, map[string]interface{}{
		"Methods": methodDataList,
	}); err != nil {
		return err
	}

	// Format code
	formatted, err := format.Source([]byte(buf.String()))
	if err != nil {
		return err
	}

	// Write to file
	outputPath := filepath.Join("..", "..", "api", "api_gen.go")
	return os.WriteFile(outputPath, formatted, 0644)
}

func generateBroadcastMethods() error {
	operations := broadcast.OperationsData

	// Process operations for template
	type OpData struct {
		MethodName     string
		Operation      string
		OpType         string
		ParamsSignature string
		OpFields       string
		Role           string
	}

	opDataList := make([]OpData, 0, len(operations))
	for _, op := range operations {
		methodName := toCamelCase(op.Operation)
		opType := toOpType(op.Operation)
		paramsSig := buildBroadcastParamsSignature(op.Params)
		opFields := buildOpFields(op.Params)
		role := "posting"
		if len(op.Roles) > 0 {
			role = op.Roles[0]
		}

		od := OpData{
			MethodName:      methodName,
			Operation:       op.Operation,
			OpType:          opType,
			ParamsSignature: paramsSig,
			OpFields:        opFields,
			Role:            role,
		}
		opDataList = append(opDataList, od)
	}

	// Generate code
	tmpl, err := template.New("broadcast").Parse(broadcastGenTemplate)
	if err != nil {
		return err
	}

	var buf strings.Builder
	if err := tmpl.Execute(&buf, map[string]interface{}{
		"Operations": opDataList,
	}); err != nil {
		return err
	}

	// Format code
	formatted, err := format.Source([]byte(buf.String()))
	if err != nil {
		return err
	}

	// Write to file
	outputPath := filepath.Join("..", "..", "broadcast", "broadcast_gen.go")
	return os.WriteFile(outputPath, formatted, 0644)
}

func toCamelCase(s string) string {
	parts := strings.Split(s, "_")
	for i, part := range parts {
		if i > 0 && len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}
	return strings.Join(parts, "")
}

func toOpType(op string) string {
	parts := strings.Split(op, "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}
	return strings.Join(parts, "") + "Operation"
}

func buildParamsSignature(params []string) string {
	if len(params) == 0 {
		return ""
	}
	sig := make([]string, len(params))
	for i, p := range params {
		sig[i] = fmt.Sprintf("%s interface{}", p)
	}
	return strings.Join(sig, ", ")
}

func buildParamsValues(params []string, isObject bool) string {
	if isObject {
		return "params"
	}
	if len(params) == 0 {
		return ""
	}
	values := make([]string, len(params))
	for i, p := range params {
		values[i] = p
	}
	return strings.Join(values, ", ")
}

func buildBroadcastParamsSignature(params []string) string {
	sig := []string{"privKeyWif string"}
	for _, p := range params {
		sig = append(sig, fmt.Sprintf("%s interface{}", p))
	}
	return strings.Join(sig, ", ")
}

func buildOpFields(params []string) string {
	fields := make([]string, len(params))
	for i, p := range params {
		fields[i] = fmt.Sprintf("%s: %s,", toFieldName(p), p)
	}
	return strings.Join(fields, "\n\t\t")
}

func toFieldName(s string) string {
	parts := strings.Split(s, "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}
	return strings.Join(parts, "")
}

